#!/usr/bin/env python3

"""
Calls the GitHub API to create or update a check run
"""
from json import dumps, loads
from os import getenv, listdir, path
from sys import argv, stderr, stdin

from requests import patch, post, get, delete


def get_webhook_url(atc_url: str, team: str, pipeline: str, resource: str, webhook_token: str) -> str:
    return f"{atc_url}/api/v1/teams/{team}/pipelines/{pipeline}/resources/{resource}/check/webhook?webhook_token={webhook_token}"


def get_api_base_url(host: str) -> str:
    return "https://" + ("api.github.com" if host == "github.com" else host + "/api/v3")


ATC_EXTERNAL_URL = getenv("ATC_EXTERNAL_URL")
assert isinstance(ATC_EXTERNAL_URL, str)
ATC_EXTERNAL_URL = getenv("BUILD_TEAM_NAME")
assert isinstance(ATC_EXTERNAL_URL, str)
ATC_EXTERNAL_URL = getenv("BUILD_PIPELINE_NAME")
assert isinstance(ATC_EXTERNAL_URL, str)

required_source_fields = ("github_token", "webhook_token", "jobs")
required_job_fields = ("resource_name", "github_uri", "events")

assert len(argv) == 2

input_directory = argv[1]

assert path.exists(input_directory)
assert path.isdir(input_directory)

if len(listdir(input_directory)) > 0:
    print(
        "To improve performance, you may want to manually configure the inputs to this step.", file=stderr,
    )

concourse_input = loads(stdin.read())

assert isinstance(concourse_input, dict)
assert "source" in concourse_input, "Missing required `source` fields"
assert isinstance(concourse_input["source"], dict), "`source` must be a dict, check pipeline configuration"

for source_field in required_source_fields:
    assert source_field in concourse_input["source"], f"Missing required field `{source_field}` in `source`"

for source_field in concourse_input["source"]:
    assert source_field in required_source_fields, f"Unexpected field `{source_field}` in `source`"

jobs = concourse_input["source"]["jobs"]

assert isinstance(jobs, dict)
assert len(jobs) > 0

for job in jobs:
    assert isinstance(jobs[job], list)
    for resource in jobs[job]:
        assert isinstance(resource, dict)
        for job_field in resource:
            assert job_field in required_job_fields, f"Missing required field `{job_field}` in resource for job `{job}`"
        for job_field in required_job_fields:
            assert job_field in resource, f"Unexpected field `{job_field}` in resource for job `{job}`"


headers = {
    "Authorization": "Bearer " + concourse_input["source"]["github_token"],
    "User-Agent": "concourse-github-webhook-resource",
    "Accept": "application/vnd.github.v3+json",
}

repository_webhook_events = {}
github_hosts = set()

for job in jobs:
    for resource in jobs[job]:
        repository = resource["github_uri"]
        concourse_webhook = get_webhook_url(job, resource['resource_name'], concourse_input["source"]["webhook_token"])
        events = resource["events"]

        github_hosts.add(repository.split("/")[2])

        if repository in repository_webhook_events:
            assert concourse_webhook not in repository_webhook_events[repository]
            repository_webhook_events[repository][concourse_webhook] = events
        else:
            repository_webhook_events[repository] = {
                concourse_webhook: events
            }

assert len(github_hosts) == 1, "This resource currently only supports a single GitHub server."

for repository in repository_webhook_events:
    for concourse_webhook in repository_webhook_events[repository]:
        response = post(concourse_webhook)
        assert response.status_code == 201, f"Got unexpected status code {response.status_code} from Concourse, verify configuration is correct"

for repository in repository_webhook_events:
    github_information = repository.split("/")
    api_base_url = get_api_base_url(github_information[2])
    owner = github_information[3]
    repo = github_information[4]
    response = get(f"{api_base_url}/repos/{owner}/{repo}/hooks")
    json = response.json()
    assert response.status_code == 200, f"Got unexpected response code {response.status_code} from GitHub: {json}"
    for existing_webhook in json:
        url = existing_webhook["config"]["url"]
        if url.startswith(ATC_EXTERNAL_URL):
            if url in repository_webhook_events[repository]:
                if not set(existing_webhook["events"]) == set(repository_webhook_events[repository][url]):
                    response = patch(existing_webhook["url"], json={"events":repository_webhook_events[repository][url]}, headers=headers)
                    assert response.status_code == 200, f"Got unexpected response code {response.status_code} from GitHub: {json}"
                del repository_webhook_events[repository][url]
                continue
            last_response = existing_webhook["last_response"]
            if last_response["code"] is not None and last_response != 201:
                response = delete(existing_webhook["url"], headers=headers)
                assert response.status_code == 204, f"Got unexpected response code {response.status_code} from GitHub: {json}"
    for new_webhook in repository_webhook_events[repository]:
        response = post(f"{api_base_url}/repos/{owner}/{repo}/hooks", json={"config":{"url":new_webhook},"events":repository_webhook_events[repository][new_webhook]})
        assert response.status_code == 201, f"Got unexpected response code {response.status_code} from GitHub: {json}"

metadata = []

for repository in repository_webhook_events:
    github_information = repository.split("/")
    host = github_information[2]
    owner = github_information[3]
    repo = github_information[4]
    metadata.append(
        {
            {
                "name": repo,
                "value": f"https://{host}/{owner}/{repo}/settings/hooks"
            }
        }
    )

print(
    dumps(
        {
            "version": {"status": "ok"},
            "metadata": metadata
        }
    )
)
